sol.render
==========

.. toctree::
    :maxdepth: 2
    :titlesonly:
    :hidden:

    render/common
    render/forward
    render/deferred

The :code:`sol.render` module contains classes that implement various rendering methods. This module could be considered
the highest-level functionality that can be found in the :code:`SOL` library. It depends on most other modules. As such,
this is the place where, depending on the complexity of your use case, you might replace parts with your own. That is,
if you're not ignoring this module altogether due to its constraints.

All classes in this module can roughly be put into 4 different categories:

#. **Renderers**. These classes record the actual command buffers containing rendering commands. They might implement
   forward or deferred rendering, or do post-processing.
#. **Traversers**. These take a scenegraph and convert the nodes and linked data to a standardized format that is
   understood by the renderers.
#. **RenderData**. The classes that define the format of the data that is generated by the traversers and passed to the
   renderers.
#. **Other**. Various utility classes.

While it main not seem obvious why you'd want to have an intermediate data format between traversal and rendering, this
actually has many benefits for ease of use, extensibility, performance and more:

* A scenegraph can be invalid. For example, a mesh node might not be preceded by any materials. If the render data is
  guaranteed to always be valid, the render code can be simplified because it does not need to do any error checking.
* Implementing a new renderer does not require reimplementing traversal if the existing render data classes fit your
  needs.
* Implementing a new traverser that generates the render data in an already supported format means you can immediately
  render it.
* With a static scenegraph, traversal only needs to be done once. Linked data (e.g. materials) can still be updated, but
  if this does not affect the scenegraph the render data can be reused.
* The render data can be structured more optimally compared to the nodes in a scenegraph. Additionally, it can be
  modified or optimized for specific use cases.
